[{"title":"CEP系统 - SASE+","url":"/2019/05/10/CEP-SASE-plus/","content":"\nSASE+是SASE的延续，主要为SASE添加了对Kleene模式的支持，并且对Kleene语义，提出了三种匹配策略，均延用至今。本文参考文献：\n\n[1]. Diao, Yanlei, Neil Immerman, and Daniel Gyllstrom. \"Sase+: An agile language for kleene closure over event streams.\" *UMass Technical Report* (2007).\n\n[2]. Agrawal, Jagrati, et al. \"Efficient pattern matching over event streams.\" *Proceedings of the 2008 ACM SIGMOD international conference on Management of data*. ACM, 2008.\n\n","tags":["CEP","SASE"],"categories":["CEP"]},{"title":"CEP系统 - SASE","url":"/2019/05/07/CEP-sase/","content":"\nSASE系列的第一篇，提出了SASE语言以及NFA模型。\n\n### 背景\n\n传感器(RFID等)的大量部署催生了一大批跟踪监控的应用，如供应链管理、超市盗窃监控、医疗和环境监控等等。同时，大量部署的传感器会实时产生大量的事件需要进行过滤、复杂模式检测以及复杂事件生成等操作。\n\n为了便于说明，这里举一个超市盗窃的例子，即顾客从货架上取到货物并且未结账。为了识别这个复杂事件，要求系统支持:\n\n- 事件的存在和不存在(即否语义)的检测。\n- 时间约束例如时序、滑动窗口等\n- 属性约束\n\n而现有的系统如sub/pub系统主要致力于单个事件的过滤。流处理系统无法处理否语义。现有的复杂事件识别无法处理滑动窗口以及属性约束等等。因此，提出了SASE语言，并设计CEP系统，主要设计目标是：\n\n- 大规模流数据支持: 能处理每秒上千的事件\n- 能够持续地从大的时间窗口中提取复杂事件\n\n### SASE语言\n\n首先是<b>事件模型</b>：系统的输入是一个无限的事件序列，称为事件流。其中，每个事件都会在某个时间点瞬时且原子性地发生(即发生或不发生)，每个事件都有一个事件类型以及对应的一系列属性，且每个事件都被赋予一个时间戳。\n\n然后是<b>模式语言</b>。SASE语言都具有如下形式：\n\n{%raw%}\n\n<script type=\"text/x-mathjax-config\">\nMathJax.Hub.Config({\n  tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]}\n});\n</script>\n<script type=\"text/javascript\" async\n  src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML\">\n</script>\n$$\n\\begin{align}\n& EVENT &lt;Event\\ Pattern&gt; \\\\\n& [WHERE &lt;qualification&gt;] \\\\\n& [WITHIN &lt;Window&gt;]\n\\end{align}\n$$\n{%endraw%}\n下面介绍一下它的操作符：\n\n- **ANY**：eg  $Any(A_1, A_2, … ,A_n) $，其中 $A_1、A_2、...、A_n$表示事件类型，该操作符识别其中任何一种类型的事件发生。\n- **SEQ_**: eg $SEQ(A_1, A_2, ..., A_n) $，在不存在negation语义的情况下，**SEQ**被转化为**SEQ_**操作符，**SEQ_**接收一系列事件类型，这些事件类型的先后顺序决定识别的对应事件发生的顺序。即**SEQ_**操作符识别一系列先后发生的事件序列。另外，**SEQ_**操作符可以以**ANY**操作符作为输入\n- **SEQ_WITHOUT**: eg $SEQ(A_1, A_2, …, A_{i-1},  !A_i, A_{i+1}, …, A_n)$，在存在negation语义的情况下，**SEQ**被转化为**SEQ_WITHOUT**操作符，表示在先后发生的$A_1、A_2、…、A_{i-1}$以及$ A_{i+1}, …, A_n$类型事件之间，不发生$A_i$类型的事件。**SEQ_WITHOUT**操作符存在两种特例，一是如$SEQ(!A_1, A_2)$的以否开始的序列，一种是如$SEQ(A_1, !A_2)$的以否结束的序列，这两种序列只能和**WITHIN**语句结合起来使用。\n- **Selection**：作用与**WHERE**语句的操作符，是一系列由**$\\land$(与)**和**$\\lor$(或)**连接起来的简单的参数化的**predicates**。用于筛选事件。\n- **WITHIN_**：由**WITHIN**语句翻译而来，定义了**SEQ**语句中事件序列的最大时间跨度。\n\n### 几点限制\n\n- 只支持原始类型的事件到复杂类型的事件之间的转化，不支持复杂类型事件到复杂类型事件之间的转化\n- 不能处理乱序\n- 对Aggregation支持有限\n\n### 基本识别模型\n\n以Query：\n\n{%raw%}\n$$\n\\begin{align}\n& EVENT\\  SEQ(A\\ x_1,B\\ x_2,!C\\ x_3 ,D\\ x_4) \\\\\n& WHERE\\  [attr1, attr2] \\land x1.attr3 = ‘1’ \\land x1.attr4 < x4.attr4 \\\\\n& WITHIN\\  T\n\\end{align}\n$$\n{%endraw%}\n为例，SASE的基本识别模型如图所示\n<img src=\"/images/sase_basic_query_plan_model.jpg\" alt=\"基本识别模型\" style=\"width:75%\">\n\n共分为五个部分：\n\n- **Sequence scan and construction(SSC)**： 序列扫描和构造，SSC处理query中的存在(positive)语义组成的序列，得到子序列(例中SEQ(A, B, D))，然后扫描输入流并得到序列。这个过程是基于NFA来实现的。对应子序列SEQ(A, B, D)，其NFA模型如下图所示。其中0、1、2、3表示状态，0为起始状态，3为终止状态。状态之间的边表示状态迁移的条件。我们可以注意到其中每个状态还存在指向自身的*边，这条边可以和向前边同时执行，以跳过不匹配的事件以及在事件匹配时保留当前序列的状态。同时，使用一个执行栈来记录运行过程中活跃的状态，状态变化在栈中使用前向指针来表示。最终使用DFS算法从每个终止状态出发遍历所有到达起始状态的且不存在相邻的相同状态的路径即可得到匹配序列。\n\n  <img src=\"/images/sase_basic_nfa.jpg\" alt=\"nfa模型及执行栈\" style=\"width:75%\">\n\n- **Selection($\\sigma$)**：根据**WHERE**语句条件对SSC提交的序列进行过滤\n\n- **Window(WD)**：根据**WITHIN**语句定义的窗口来过滤序列\n\n- **Negation(NG)**：处理**negation**语义，过滤序列。这里使用了一种叫*partitioned indexing*的技术，具体而言，就是将事件流按照固定的时间片段划分。\n\n- **Transformation(TF)**：将最终得到的序列转化为复杂事件\n\n这五个组件按照pipeline的方式组织起来，来快速得到匹配序列。\n\n### 优化\n\n上面提出了SASE的基本执行模型，但是这个模型存在一个问题：在大窗口的情况下，产生的中间结果过大导致系统负载过高，影响query性能。因此提出了几点优化\n\n#### SSC优化\n在原有SSC模型的基础上，提出了**Active Instance Stack (AIS)**来代替基础模型中的执行栈，每个NFA的状态都存在一个AIS，在SS过程中，AIS存储每一个使状态变迁到其对应状态的事件以及前置栈中的最近事件(*most recent instance in the previous stack*, RIP)。如图所示，在状态2对应的AIS中，存储了两个使状态变迁到状态2的事件即$b_3$和$b_6$，其中在状态1的AIS中发生在$b_6$之前的最近事件是$a_4$，因此$a_4$即是对应$b_6$的RIP。图中用两条虚拟边显示了$b_6$的前置事件。在SC阶段，通过一个BFS算法从终止状态的AIS栈回溯到起始状态，即可得到所有的序列。\n\n<img src=\"/images/sase_optimize_ssc.jpg\" alt=\"SSC优化\" style=\"width:75%\">\n\n#### Selection优化\n\n前面的优化只是优化了SSC的效率，并未减少无效的中间结果。在Selection优化的阶段，通过将简单的predicates提前到SSC阶段执行来对SSC执行进行剪枝。\n\n**单属性相等**：即在SEQ中的每个事件类型都存在的一个相同属性的属性值保持不变，eg 相同的RFID标签、相同的病人编号等等。对于这种predicate，最简单的方法是按照该属性将事件流划分为很多不同的小流，但是这种方法对不相关的事件也会进行partition，存在浪费。因此提出了***Partitioned Active Instance Stack*** (***PAIS***): 在SC过程中来进行划分并产生对应的一系列AIS。这样事件划分即被推迟到query之后，避免了性能损失。\n<img src=\"/images/sase_optimize_sel_pais.jpg\" alt=\"PAIS\" style=\";width:75%\">\n\n**多属性相等**：类似于单属性相等，但是有多个属性。简单的方法是对每个属性元组都进行划分。但是当划分过多时容易造成内存瓶颈。因此这里提出了两个优化方案：\n\n- Multi-PAIS：对每个属性都应用PAIS，然后取所有PAIS的结果的交集。\n- Dynamic Filtering: 只对单属性应用PAIS，对其它属性，在SC阶段进行过滤。\n\n<img src=\"/images/sase_optimize_sel_multi_pais.jpg\" alt=\"multi-PAIS\" style=\"width:75%\">\n\n#### Window优化\n\n与predicate类似，将Window判断提前到SSC过程中。\n\n<img src=\"/images/sase_optimize_query_plan_model.jpg\" alt=\"优化识别模型\" style=\"width:75%\">","tags":["CEP","SASE"],"categories":["CEP"]},{"title":"CEP系统 — Cayuga","url":"/2019/05/07/CEP-cayuga/","content":"\nCayuga是CEP系列早期的一个有影响力的系统，来源于pub/sub系统。它主要为了解决两个问题：\n\n- 支持复杂的query，例如否语义。\n- 并发query。\n\nCayuga设计了自己的query语言**Cayuga Event Language(CEL)**，以支持优化。同样使用了自动机模型。下面分三个部分介绍Cayuga：CEL、自动机模型以及系统架构。\n\n### CEL语言\n\n首先是数据模型，Cayuga中数据模型参照了数据库模型。\n\n**Event**：在Cayuga中，事件被认为是一个关联元组(relational tuple)，且包含一个起始时间$t_0$和结束时间$t_1$。\n\n**Event Stream**:  和数据库不同，在CEP中，事件流是一个按时间顺序排列的事件序列，每个事件流都包含一个固定的关联模式(relational schema)。事件在事件流中按结束时间$t_1$排列，这个时间也称为**检测时间(detection time)**。检测时间相同的事件被认为同时发生。\n\n然后是CEL语言，这里以股票应用为例。首先定义了一个股票事件模型：$Stock(Name, Price, Volume)$。 每个CEL Query都具有以下形式：\n{%raw%}\n<script type=\"text/x-mathjax-config\">\nMathJax.Hub.Config({\n  tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]}\n});\n</script>\n<script type=\"text/javascript\" async\n  src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML\">\n</script>\n$$\n\\begin{align}\n& SELECT\\ &lt;attributes&gt; \\\\\n& FROM\\ &lt;stream expression&gt; \\\\\n& PUBLISH\\ &lt;output stream&gt;\n\\end{align}\n$$\n{%endraw%}\n\n这里的SELECT语句和SQL中的SELECT非常类似，都指定的输出模式中的属性名或聚合操作，并可以使用**AS**关键字来重命名。SELECT语句可以省略，若省略则相当于SELECT \\*。PUBLISH语句指定的输出流的名字，以便其它QUERY可以它为输入。最简单的QUERY如：\n{%raw%}\n$$\n\\begin{align}\n& SELECT\\ * \\\\\n& FROM\\ Stock \\\\\n& PUBLISH\\ MyStock\n\\end{align}\n$$\n{%endraw%}\nFROM语句定义了流表达式，这是整个Query的核心。一个流表达式表明了数据的来源，并且支持了一元构造器FILTER和二元构造器NEXT和FOLD，并且支持在FROM语句中嵌套其它QUERY。下面分别介绍这些构造器。\n\n**FILTER**: 顾名思义，$FILTER\\{ predExpr \\}(stream)$是对输入流进行过滤的构造器。下面的例子定义了一个简单的Query从股票流中过滤出IBM的价格大于83的数据形成新的流。另外，在FILTER构造器中事件有一个特殊的属性DUR，实际上DUR指的是事件发生的时间间隔$t_1-t_0$。\n{%raw%}\n$$\n\\begin{align}\n& SELECT\\ Price\\ AS\\ IBMPrice \\\\\n& FROM\\ FILTER\\{name='IBM'\\ and\\ Price > 83\\}(stock) \\\\\n& PUBLISH\\ IBMStock\n\\end{align}\n$$\n{%endraw%}\n**NEXT**: $S_1\\ NEXT\\{predExpr\\}(S_2)$，其中$S_1$和$S_2$是两条流。NEXT构造器输入一个事件对($e_1, e_2$)的流，其中$e_1$来自流$S_1$，$e_2$是$e_1$发生后$S_2$中发生的下一个满足predExpr的事件。下面是一个例子，用来提取价格大于83的IBM股票价格以及之后的Microsoft股票的价格:\n{%raw%}\n$$\n\\begin{align}\n& SELECT\\ IBMPrice,\\ Price\\ AS\\ MSFTPrice \\\\\n& FROM\\ IBMStock\\ NEXT\\{Name='MSFT'\\}(Stock) \n\\end{align}\n$$\n{%endraw%}\n另外，当NEXT的两个输入流中含有相同的属性时，为了避免冲突，使用$\\$1.foo$表示左流的属性，$\\$2.foo$表示右流的属性。\n\n**FOLD**: $S_1\\ FOLD\\{predExpr_1, predExpr_2, aggExpr\\}(S_2)$，其中$S_1$和$S_2$是两条流，FOLD构造器用于在流中迭代选择事件。其中$predExpr_1$用于选择迭代的事件，$predExpr_2$定义了迭代条件，$aggExpr$定义了迭代过程中的aggregation操作。FOLD构造器同样使用$\\$1$和$\\$2$来区分两条流，并使用$\\$$来表示最后一次迭代的$S_2$中的事件。在FOLD构造器中，$S_1$的模式必须是$S_2$的模式的一个超集。下面这个例子描述了一个公司的股票在一次交易量Volume大于10000后价格持续上升至少10次的事件:\n{%raw%}\n$$\n\\begin{align}\n& SELECT\\ * \\\\\n& FROM\\ FILTER\\{cnt > 10\\}(\\\\\n& \\quad (SELECT *,\\ 1\\ as\\ cnt \\\\\n& \\quad FROM\\ FILTER\\{Volumn \\gt 10000\\}(Stock)) \\\\\n& \\quad \\quad FOLD\\{$_2.Name=$.Name, $_2.Price \\gt $.Price, $.cnt + 1\\ AS\\ cnt\\}(Stock))\n\\end{align}\n$$\n{%endraw%}\n\n### 自动机模型\nCayuga也是使用自动机模型来进行匹配，下面以一个例子介绍其自动机模型。\n{%raw%}\n$$\n\\begin{align}\n& SELECT\\ Name \\\\\n& FROM\\ (SELECT\\ Name\\ as\\ N\\ FROM\\ Stock)\\ Next\\{$1.N=$2.Name\\}(Stock)\n\\end{align}\n$$\n{%endraw%}\n其对应的自动机模型如图所示\n<img src=\"/images/cayuga_nfa.png\" alt=\"Cayuga自动机模型\" style=\"width:75%\">\n图中的$Q_0、Q_1、Q_2$表示自动机中的状态。它们分别被赋予了固定的关联模式以及对应的输入流。具体而言，$Q_0$被赋予了输入流Stock以及其关联模式。$Q_1$被赋予了关联模式N和输入流Stock。$Q_2$被赋予了关联模式Name，输入流是最终生成的流。每个状态的出边都具有$<\\theta, f>$的形式，其中$\\theta$表示对于输入流和该状态的关联模式的断言， 而$f$定义了从从该状态的输入以及关联模式到下一个状态的关联模式的映射。从图中可以看到，在Cayuga的自动机模型中，存在两种边，一种是从一个状态指向另一个状态的边，一种是指向自身状态的边。对于指向自身的边，只会在存在二元构造器时出现，如果这条边的断言是来自于过滤的断言(NEXT中的predExpr，FOLD中的$predExpr_1$)， 那么这种边被称为*过滤边(filter edges)*，对应的断言被称为*过滤断言(filter predicates)*。如果其断言来自于属性rebind的断言(FOLD中的$predExpr_2$)，则被称为*rebind edge*，对应的断言被称为*rebind predicates*。所有其它的边都被称为*前向边(forward edges)*。每一个中间状态，如果只存在过滤边，则构成NEXT构造器，如果既存在过滤边，也存在rebind edge，那么构成FOLD构造器。\n\n### 基于自动机的匹配\nCayuga的匹配流程如下：\n\n对一个状态而言，对每一个输入事件，按如下顺序匹配：\n  1. 匹配filter edge，若为NEXT构造器，更新对应的数据item\n  2. 匹配rebind edge，若为FOLD构造器，更新对应的数据item\n  3. 匹配forward edge，在该edge的出状态下生成新的数据item\n\n对每一个状态，接收其输入流中的事件并进行匹配，最终持续生成匹配结果流，存储在终止状态中。\n\n### 与SASE的对比\n\n- 在语言层面，SASE语言更为简洁明了\n- 在操作支持方面，都支持SEQ匹配以及否语义，但Cayuga额外可以有限度地支持未知长度的序列即Kleene语义\n- SASE针对事件序列的匹配，而Cayuga更倾向于匹配过程中的Aggregation。\n- Cayuga可以支持复杂事件多层次的匹配，而SASE需要级联来完成。\n- Cayuga在系统实现上可以有限度地支持乱序","tags":["CEP","Cayuga"],"categories":["CEP"]},{"title":"CEP-起源(一)","url":"/2019/05/05/CEP-beginning/","content":"\nCEP的起源来自于斯坦福大学David C.Luckham教授领导的Program Analysis and Verification Group(PAVG)研究小组。1995年，该小组在IEEETransactions on Software Engineering上发表了一篇文章，推出了RAPIDE<sup>[[1][]]</sup>。RAPIDE是一种事件驱动的针对分布式系统原型设计的语言，它提供以下能力：\n\n- 解释系统各个组件模型\n- 提供一个执行模型并能记录执行过程中的各种行为\n- 定义事件之间的关联以及约束以及映射\n\n1998年，该小组提出了Event Processing Network(EPN)的概念并详细解释了CEP<sup>[[2][]]</sup>等介绍了CEP在分布式系统中的应用。\n\n后两年，同校的Louis Perrochon教授和该小组合作将CEP的应用推广至商业管理、pub/sub系统等方面并设计出EPN的模型<sup>[[3][]][[4][]]</sup>。\n\n下面我会详细介绍一下EPN的概念以及CEP的提出。\n\n分布式系统一般都有一个交流层，用于系统中不同组件之间的消息传输，它位于系统的底层，是分布式系统的基础。然而交流层很容易出现错误，每次出现错误，都可能造成整个系统的停摆。因此，大部分分布式系统都会内置诊断措施来解决网络问题，他们使用交流层来记录日志数据(或者成为事件/event)，系统管理员可以分析网络日志来发现问题并采取措施，有很多工具可以辅助这一过程。然而这种方式仍然停留在原始的、低级的层面。存在很多问题：\n\n- 日志中记录的事件是很低层次的数据\n\n- 数据量非常大\n\n- 相关的事件掺杂在大量不同其它事件中，且可能分布在不同的时间片。\n\n- 日志数据缺乏因果关系。\n\n因此，现有的方式很难很好地对交流层日志进行分析得出有效的结果。\n\n另一方面，如果需要分析日志得到应用层面的信息会更加复杂。现今的低层级日志数据很难在解决应用层面问题上起到作用。而要达到这个目的，需要将高层级操作与低层级的数据交流日志联系起来，这种技术暂时还无法实现。\n\n最后，当前的系统只给内置操作加入日志监测，而更高层级如应用层等没有日志。并且缺乏对不同类型事件的分析。\n\n因此，作者提出了一种新的系统监测和分析工具，这种工具的最基础就是聚合低层级的事件转化为高层级的事件，并且它具有以下能力：\n\n- 能轻易地将有效事件从大量事件日志中过滤出来。\n- 将低层级事件聚合为高层级事件来表示其更复杂的意义\n- 在不同时间段内根据因果关系将发生的事件检测出来\n- 监测事件日志，并按照严格的模式自动监测违规事件\n\n作者将这种技术称为RAPIDE Complex Event Processing。并为此对事件做了抽象，作者认为事件可以分层，底层的事件是确切的事件，表示了一个确定的操作。高层的事件是虚拟的事件，它们是底层事件的集合。并且为了确切地分级，需要指定不同层级事件之间的映射关系。因此这里引入了一个概念: <b>poset</b>(partially ordered set of events，这里翻译为有序部分事件集合)，一个poset包含一系列的事件集合以及它们之间的关系。并且定义了两种操作:\n\n- <b>filters(过滤)</b>: 接受posets作为输入并输出输入的一部分。通过事件模式(event patterns)来定义。主要是为了过滤无效事件\n- <b>maps(映射)</b>: 接受posets作为输入并产生新的事件。被定义为输入和输出事件模式对。任何满足输入模式的事件集合将会根据对应的输出模式产生新的事件。Maps也被称为<b>aggregator(聚合器)</b>。目的是构造高层级事件。\n\n通过这些操作，管理员可以轻易地观测不同事件层级发生的事件来对系统进行监测，来对系统错误进行快速反应。\n\n\n\n\n[1]:https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=385971\t\"Specification and Analysis of System  Architecture  Using  Rapide\"\n[2]:https://www.unix.com/pdf/CEP_in_distributed_systems.pdf\t\"Complex Event Processing in Distributed Systems\"\n[3]: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.35.7689&rep=rep1&type=pdf \"Real Time Event Based Analysis of Complex Systems\"\n[4]:http://infolab.stanford.edu/pub/cstr/reports/csl/tr/99/788/CSL-TR-99-788.pdf  \"Managing Event Processing Networks\"\n\n","tags":["CEP"],"categories":["CEP"]},{"title":"CEP系列调研 — 目录","url":"/2019/04/28/cep-survey-catalogue/","content":"\n### Complex Event Processing\n\nCEP(Complex Event Processing)是一种根据给定pattern从数据流中识别特定的数据序列的一类技术。本系列文章旨在调研CEP的发展历程，并对最新的CEP系列技术做详细的了解。\n\n从功能上讲，可以将CEP分为CER(Complex Event Processing)以及Aggregation两个方面。其中，CER主要用于对特定序列的识别，Aggregation主要致力于提取识别序列的统计信息。在早期的系统中，Aggregation往往是基于CER的，但在最新的一些文章中，提出了一些不基于识别的online系统。\n\n从系统上分，CEP早期主要是单机非并行来处理。而随着大数据时代的到来，数据流逐渐向大规模高速的方向演化，产生了DCEP分支。CEP向分布式处理发展。\n\n另外，在某些领域，存在着对单个数据流同时进行多个Query的情况。因此，产生了模式share的一些研究来共享多Query识别的资源。\n\n### 文章列表\n\n下面是系列CEP文章目录，以下文章不完全按时间倒序排布：\n\n- Complete Event Trend Detection in High-Rate Event Streams<sup>[[1][]]</sup>\n\n  CET(Complete Event Trend)识别主要针对包含单个kleene模式的Query识别进行优化，采用了图模型的方式共享中间序列(partial sequence)存储，降低了存储冗余。同时，采用hybrid的识别方式从图中提取最终结果。\n\n- On complexity and optimization of expensive queries in complex event processing<sup>[[2][]]</sup>\n\t\n\t本文是[SASE系列](http://avid.cs.umass.edu/sase/index.php)的一个升级版，针对复杂Query进行分析找出低效的操作并将这个操作延后进行来提高系统的处理能力。\n\n- SASE+\n\n  - Efficient pattern matching over event streams<sup>[[3][]]</sup>\n  - SASE+: An Agile Language for Kleene Closure overEvent Streams<sup>[[4][]]</sup>\n\n  SASE+，提出了对Kleene模式的支持，提出了kleene匹配的改进NFA模型。这两篇文章一个是详细介绍了改进的NFA匹配模型。一个详细介绍了SASE+语言，特别是针对Kleene的匹配。\n\n- High-performance complex event processing over streams<sup>[[5][]]</sup>\n\n  SASE，提出了SASE语言来进行CEP，使用NFA模型进行CEP并进行了若干优化。\n\n- TelegraphCQ: Continuous Dataflow Processing for an Uncertain World<sup>[[6][]]</sup>\n\n  加州大学伯克利分校推出的一个系统，主要解决的问题是:\n\n  - 在数据流中做query而不是数据库\n  - 持续query: window,slide\n  - query之间的share以提高系统效率\n\n- Efficient Filtering of Composite Events<sup>[[7][]]</sup>\n\t\n\t在ENS(Event Notification Services)系统中，识别与(同时发生)、或(至少一个发生)、非(一段时间不发生)以及简单序列\n\n- Temporal Management of RFID Data<sup>[[8][]]</sup>\n\n\t一个RFID中间件，主要是基于关系型数据库来做的，将query转化为对应的数据库操作。\n\n- Real Time Event Based Analysis of Complex Systems<sup>[[9][]]</sup>\n\n- Complex Event Processing in Distributed Systems<sup>[[10][]]</sup>\n\n- Managing Event Processing Networks<sup>[[11][]]</sup>\n\n  对CEP的概念和应用做了较为详细的说明\n\n------\n\n- Cayuga\n  - Cayuga: A General Purpose Event Monitoring System<sup>[[12][]]</sup>\n  - Towards Expressive Publish/Subscribe Systems<sup>[[13][]]</sup>\n  \n  这两篇文章介绍了Cayuga，9主要针对Cayuga系统的设计及实现，10介绍了基于Cayuga的Pub/Sub系统\n\n- ZStream: A Cost-based Query Processor for Adaptively Detecting Composite Events<sup>[[14][]]</sup>\n\n- E-Cube: multi-dimensional event sequence analysis using hierarchical pattern query sharing<sup>[[15][]]</sup>\n\n- Complex event analytics: online aggregation of stream sequence patterns<sup>[[16][]]</sup>\n\n- High-performance complex event processing over XML streams<sup>[[17][]]</sup>\n\n***\n- Complex Event Recognition in the Big Data Era<sup>[[18][]]</sup>\n\n[1]:https://dl.acm.org/citation.cfm?id=3035947\n[2]:https://dl.acm.org/citation.cfm?id=2593671\n[3]:https://dl.acm.org/citation.cfm?doid=1376616.1376634\n[4]:http://avid.cs.umass.edu/sase/uploads/pubs/07-03.pdf\n[5]: https://dl.acm.org/citation.cfm?doid=1142473.1142520\n[6]: http://www-db.cs.wisc.edu/cidr/cidr2003/program/p24.pdf\n[7]:https://link.springer.com/chapter/10.1007%2F3-540-45073-4_17\n[8]: http://www.vldb.org/archives/website/2005/program/paper/wed/p1128-wang.pdf\n[9]:http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.35.7689&amp;rep=rep1&amp;type=pdf\n[10]:https://www.unix.com/pdf/CEP_in_distributed_systems.pdf\n[11]:http://infolab.stanford.edu/pub/cstr/reports/csl/tr/99/788/CSL-TR-99-788.pdf\n[12]:http://cidrdb.org/cidr2007/papers/cidr07p47.pdf\n[13]:https://link.springer.com/content/pdf/10.1007%2F11687238_38.pdf\n[14]:https://dl.acm.org/citation.cfm?doid=1559845.1559867\n[15]:https://dl.acm.org/citation.cfm?doid=1989323.1989416\n[16]:https://dl.acm.org/citation.cfm?doid=2588555.2593684\n[17]:https://dl.acm.org/citation.cfm?doid=2213836.2213866\n[18]: http://www.vldb.org/pvldb/vol10/p1996-giatrakos.pdf","tags":["CEP"],"categories":["CEP"]},{"title":"Hexo开发 — apollo主题Tag开发","url":"/2019/04/26/apollo-theme-edit/","content":"\n[apollo](https://github.com/pinggod/hexo-theme-apollo)是一个简洁美观的主题，该主题已不再更新。实际使用过程中发现该主题缺少对标签和分类的支持，因此fork了一下这个项目，准备自己开发标签和分类页面支持。\n\n# Hexo主题开发\n\nHexo的主题创建时非常简单的，只需要在theme文件夹内创建一个新的文件夹，文件夹的内容一般至少包含这几个文件或文件夹\n\n```\n├── _config.yml      //主题的配置文件\n├── languages\t\t\t\t//语言文件夹\n├── layout\t\t\t\t\t//页面模板文件夹\n├── scripts\t\t\t\t\t//脚本文件夹\n└── source\t\t\t\t\t//资源文件夹\n```\n\n#### _config.yml\n\n配置文件，所有配置会存储在全局变量theme中\n\n#### languages\n\n定义国际化相关的语言文件夹\n\n#### layout\n\n布局文件夹，页面的主题模板在这里定义。默认支持swig模板引擎，可以通过插件支持EJS、Hami或者Jade支持\n\n#### scripts\n\n脚本文件夹。定义用于页面的插件，如果该插件不需要发布到npm上，可以直接在scripts文件夹中定义\n\n#### source\n\n资源文件夹，除了模板以外的 Asset，例如 CSS、JavaScript 文件等，都应该放在这个文件夹中。文件或文件夹开头名称为 `_`（下划线线）或隐藏的文件会被忽略。\n\n如果文件可以被渲染的话，会经过解析然后储存到 `public` 文件夹，否则会直接拷贝到 `public` 文件夹。\n\n\n\n# apollo标签支持\n\n根据上面的介绍可以发现如果需要增加页面模板，需要在layout文件夹内编写模板文件，然后将新的页面的layout定义为该模板。\n\n查看apollo的layout文件目录\n\n```\nlayout\n├── archive.jade\n├── index.jade\n├── mixins\n│   ├── paginator.jade\n│   └── post.jade\n├── partial\n│   ├── comment.jade\n│   ├── copyright.jade\n│   ├── head.jade\n│   ├── layout.jade\n│   ├── nav.jade\n│   └── scripts.jade\n└── post.jade\n```\n\n可以发现这里使用了jade模板引擎，jade的语法较为简单，参考[jade官网](http://jade-lang.com/)文档基本可以完成简单的网页模板设计。\n\n我们可以发现这里确实tag页面和category页面的模板。新建```tag.jade```和```category.jade```文件。为了在博客列表已经博客页面共用tag的模板，在mixins文件夹下创建```tags.jade```文件夹。","tags":["Hexo","apollo"]},{"title":"Jupyter常用配置","url":"/2019/04/19/jupyter/","content":"\n主要记录一下Jupyter notebook的一些配置，方便以后查阅。\n\n## 安装\n\n```bash\n$ pip install jupyter\n```\n\n## 配置\n\n#### 生成配置文件\n\n```bash\n$ jupyter notebook --generate-config\n```\n\n#### 设置密码\n\n```bash\n$ jupyter notebook password\nEnter password:\nVerify password:\n```\n\n如果这里显示\n\n```bash\nFileNotFoundError: [Errno 2] No such file or directory: 'home/xxx/.jupyter/jupyter_notebook_config.json'\n```\n\n手动在根目录新建文件夹\n\n```bash\n$ mkdir ~/.jupyter\n```\n\n在默认配置文件~/.jupyter/jupyter_nodebook_config.py中输入\n\n```python\nc.NotebookApp.password = 'sha1:...'\n```\n\n密文为刚刚生成的密文，在jupyter_notebook_config.json中\n\n#### 远端访问\n\n  打开默认配置文件~/.jupyter/jupyter_nodebook_config.py\n\n  ```python\nc.NotebookApp.ip = '0.0.0.0' // 所有ip均可访问,注意网上说这里可以用*，但是我实测发现*会报错\nc.NotebookApp.open_browser = False //禁止自动打开文件夹\nc.NotebookApp.port = 15000\n  ```\n\n#### 使用matplotlib\n\n  ```python\nimport matplotlib.pyplot as plt\n%matplotlib inline\n  ```\n\n#### 自动补全\n使用jupyter_contrib_nbextensions\n\n  ```bash\n$ pip install jupyter_contrib_nbextensions\n$ jupyter contrib nbextension install --user\n$ pip install jupyter_nbextensions_configurator\n$ jupyter nbextensions_configurator enable --user\n  ```\n\n然后重启jupyter，在出现的Nbextensions菜单下勾选Hinterland插件\n\n不定时更新。。。","tags":["Jupyter"]},{"title":"初识hexo","url":"/2019/04/18/hexo-plugin/","content":"\n一直想写博客，但是个人比较懒，今天终于下定决心用hexo搭了一个博客网站。选hexo的主要原因是我喜欢用markdown，然后我的服务器也差不多到期了，用hexo可以挂在github上比较方便。\n\n#### 搭建\n\n基于hexo搭建博客网站比较简单。这里主要参考了[使用hexo+github搭建免费个人博客详细教程](https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html)。文章写得很详细，我这里就不多说了。主要说下遇到的几个问题。\n\n#### github pages配置\n\n首先碰到的问题是搭建完成后访问我的github page出现404错误。这里主要的问题是GitHub仓库名出错了，必须是<github用户名>.github.io。改名后就可以正常访问了。\n\n在解决这个问题过程中还发现了github仓库setttings下面有一个github pages配置，可以切换显示的branch和主题。\n\n#### 图标问题\n\n我是用的主题是[apollo](https://github.com/pinggod/hexo-theme-apollo)，这个主题比较清爽。不过搭建之后发现它有一个很丑的默认图标，这个肯定是不能忍的了。由于hexo以及这个主题文档都没有提及图标修改，所以搞了半天。\n\n最开始的办法是找到这个主题的文件夹theme/apollo，发现它的source目录下有一个favicon.png和默认图标是一样的，于是我就将我的图标复制替换了这个默认图标，果然页面的图标修改成功了。不过一直感觉这样做肯定不是一个正确的做法，毕竟这样设计太合理了。所以就去看了一下这个主题的源码，我在theme/apollo/layout文件夹下发现了一堆jade结尾的文件，这些都是jade模板引擎的文件。不过我都看不懂|(*′口`)。不过大概看了一下，发现有几个文件里面写着\n\n```jade\nlink(rel=\"icon\", href=url_for(theme.favicon))\n```\n\n```jade\na.logo-link(href=url_for())\n  img(src=url_for(theme.logo) alt=\"logo\")\n```\n\n大致猜了一下这里就是指向图标的位置。这里发现了一个theme变量，于是去查文档(不得不说hexo的文档真的不是初学者看得懂的)，只看到了一个theme变量的介绍是继承自网站配置，但是根目录下的\\_config.yml文件中的theme明显不可能包含变量，但是完全不知道在哪定义的。直到我偶然发现主题文件夹下面有一个_config.yml的文件，里面有一个\n\n```yaml\nfavicon: favicon.png\nlogo: favicon.png\n```\n\n所以很明显，定义的位置在这里。改为自定义的路径即可。\n\n\n\nhexo整体的搭建还是挺简单的，网上教程也比较多，但是官方文档是真的难看懂。另外一个问题是github访问好慢。。。后面准备把图片之类的上传到七牛云上去了，准备写一个插件打包的时候自动上传并修改url。","tags":["Hexo","博客"]}]